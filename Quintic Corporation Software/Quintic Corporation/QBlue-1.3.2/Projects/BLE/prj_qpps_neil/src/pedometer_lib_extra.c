// performs pedometer and misc functions 
#include <math.h> 
#include <stdlib.h>
#include "app_env.h"
#include "lib.h"
#include "accel_lib.h"
#include "pedometer_lib.h"

//for simple pedometer
#define PED_THRESHOLD_LOW 6
#define PED_THRESHOLD_HIGH 20

volatile uint32_t steps = 0;
//volatile float distance;
volatile uint32_t distance = 0;
 
//helper function to get total steps
uint32_t getSteps(void)
{
	QPRINTF("Total Steps: %d\r\n", steps);
	return steps;
}

//helper function to get total distance
uint32_t getDistance(void)
{
	QPRINTF("Total Distance: %d\r\n", distance);
	return (int)distance;
}
/**
 ****************************************************************************************
 * @brief Measures difference between two samples, if within threshold bounds it is 
 *        marked as a step. A small debounc is added to make sure one large event is
 *        registered twice. About 50%-80% accurate.
 ****************************************************************************************
 */
uint8_t debounce = 0;

void basic_pedometer(int8_t xdat)
{
	
	int8_t oldx = 0;
	//int8_t xdat, ydat, zdat; 
	//steps = 0;
	//while(1)
	//{
		//accel_get_sample(&xdat, &ydat, &zdat, ACCEL_X);
		if(xdat - oldx > PED_THRESHOLD_LOW && xdat - oldx < PED_THRESHOLD_HIGH)
		{
			if(debounce > 0)
			{
				debounce--;
			}
			else
			{
				steps++;
				QPRINTF("%d, %d\r\n", steps, xdat - oldx);
				debounce = 2;
			}
		}
		//QPRINTF("%d\r\n", (xdat - oldx));
		oldx = xdat;
	//}
	
}



/**
 ****************************************************************************************
 * @brief Very accurate pedometer (95+%) based on:
 *        "A Gyroscope Based Accurate Pedometer Algorithm" by Sampath Jayalath
 *        This function detects the positive pulses of the sin wave generated by
 *        walking. The accelerometer is using it's built-in high-pass filter to
 *        automatically return to zero and remove gravity.
 * Algorithm:
 * https://cuatrg.files.wordpress.com/2014/06/accurate-pedometer-for-smartphones.pdf
 * 
 * Distance Calculations:
 * http://www.rehab.research.va.gov/jour/04/41/6/pdf/Orendurff.pdf
 * http://scienceofsportsperformance.wordpress.com/2013/01/25/speed-development-plyometric-training/
 ****************************************************************************************
 */

#define ST_INIT 					0
#define ST_ZERO_NEGATIVE	1
#define ST_LOWER_PEAK			2
#define ST_ZERO_POSITIVE	3
#define ST_HIGHER_PEAK		4
#define ST_CALC_STEP			5
#define ST_TIMER_WAIT			6

#define ZERO_DELAY 				8
#define MIN_THRESHOLD 		5
#define MAX_THRESHOLD 		100
#define SAMPLE_RATE 			50 //accelerometer sample rate

int8_t samples[4];
int16_t samp_last;
uint16_t time_since_last_step = 0, step_timer = 0;;
uint8_t samp_num = 0;
uint8_t state = ST_INIT;

#define MAN

#if (defined(MAN))
	uint8_t stride_length[10] = {110,109,108,105,100,90,76,60,46,38}; //distance/step in cm	
#elif (defined(WOMAN))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm	
#elif (defined(CHILD))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm
#endif
	
void better_pedometer(int8_t xdat)
{
	//int8_t xdat, ydat, zdat;
	uint8_t  i;
	int16_t samp;
	
	//QPRINTF("%d, %d\r\n", xdat, state*4);
	
	/*if(time_since_last_step > 100)//2 seconds
	{
		//TODO: reduce sample rate and switch to slow sample sleep mode
	}*/

	//wait for enough samples to filter
	if(samp_num > 3)
	{
		//copy new sample to filter array
		for(i=0;i<3;i++)
		{
			samples[i] = samples[i+1];
		}
		samples[3] = xdat;
		
		//low pass filter
		samp = 0;
		for(i=0;i<4;i++)
		{
			samp += samples[i];
		}
		samp /= 4;
		
		//QPRINTF("%d\r\n", state);
		
		switch(state)
		{
			case ST_INIT:
				if(samp_last >= 0 && samp <= -1) //zero crossing detector going down
				{
					state = ST_ZERO_NEGATIVE;
					time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
					step_timer = 0;// restart step timer
				}
			
				break;
			
			case ST_ZERO_NEGATIVE:
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp < -MIN_THRESHOLD) //lower peak
					state = ST_LOWER_PEAK;
				else if(samp < -MAX_THRESHOLD) //peak too low, not a real step
					state = ST_INIT;
				else if(samp >= 0) //Fake zero crosing
					state = ST_INIT;
				
				break;
			
			case ST_LOWER_PEAK:
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp_last <= 0 && samp >= 1) //zero crossing detector going up
					state = ST_ZERO_POSITIVE;
				else if(samp < -MAX_THRESHOLD) //peak too low, not a real step
					state = ST_INIT;
				
				break;
			
			case ST_ZERO_POSITIVE:
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp > MIN_THRESHOLD) //lower peak
					state = ST_HIGHER_PEAK;
				if(samp > MAX_THRESHOLD) //peak too high, not a real step
					state = ST_INIT;
				else if(samp <= 0) //Fake zero crosing
					state = ST_INIT;
				
				break;
			
			case ST_HIGHER_PEAK:
				time_since_last_step++;// increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp < MIN_THRESHOLD) //peak on it's way down, step found
					state = ST_CALC_STEP;
				
				break;
			
			case ST_CALC_STEP:
				step_timer++;
				if(step_timer > ZERO_DELAY) //ready for next step
				{
					//bypass init if zero corssing is happening already
					if(samp_last >= 0 && samp <= -1)
					{
						state = ST_ZERO_NEGATIVE;
						step_timer = 0;// restart step timer
					}
					else
					{
						state = ST_INIT;
					}
				}
				else
				{
					state = ST_TIMER_WAIT;
				}

				steps++;
				
				//compute distance traveled as inverse of step timer
				if(time_since_last_step > SAMPLE_RATE) //1 seconds since last step, too long for any cadence 
				{
					distance += stride_length[9]; //smallest step size
				}
				else if(time_since_last_step < 20 && time_since_last_step > 11 ) //log table lookup
				{
					distance += stride_length[time_since_last_step-12];
				}
				else //super human fast!!!
				{
					distance += stride_length[0];
				}
				
				time_since_last_step = 0; //restart distance calculator
				//QPRINTF("\r\nsteps: %d\r\n", steps);
				
				break;
				
			case ST_TIMER_WAIT:
				step_timer++;
				if(step_timer > ZERO_DELAY) //ready for next step
					state = ST_INIT;
				
				break;
			
			default:
				break;
			
		} //end switch
		
		samp_last = samp;
	}
	else //wait for enough samples
	{
		samples[samp_num] = xdat;
		samp_num++;
		
		//low pass filter
		samp_last = 0;
		for(i=0;i<4;i++)
		{
			samp_last += samples[i];
		}
		samp_last /= 4;
	}

	
}
	
/*	
void better_pedometer(int8_t xdat)
{
	//int8_t xdat, ydat, zdat;
	uint8_t  i;
	int16_t samp;
	
	// increase timer by 1/sample rate seconds (20ms)
	time_since_last_step++;
	
	QPRINTF("%d\r\n", xdat);
	
	*if(time_since_last_step > 500)
	{
		//TODO: reduce sample rate and switch to slow sample sleep mode
	}*

	//wait for enough samples to filter
	if(samp_num > 3)
	{
		//copy new sample to filter array
		for(i=0;i<3;i++)
		{
			samples[i] = samples[i+1];
		}
		samples[3] = xdat;
		
		//low pass filter
		samp = 0;
		for(i=0;i<4;i++)
		{
			samp += samples[i];
		}
		samp /= 4;
		
		if(samp_last <= 0 && samp >= 1) //zero crossing detector going up
		{	
			cross_found = 1;
		}
		
		if(cross_found)
		{
			//is peak larger than threshold?
			if(samp > MIN_THRESHOLD && zero_crossed == 0)
			{
				steps++;
				
				//compute distance traveled as inverse of step timer
				if(time_since_last_step > SAMPLE_RATE) //1 seconds since last step, too long for any cadence 
				{
					distance += stride_length[9]; //smallest step size
				}
				else if(time_since_last_step < 20 && time_since_last_step > 11 ) //log table lookup
				{
					distance += stride_length[time_since_last_step-12];
				}
				else //super human fast!!!
				{
					distance += stride_length[0];
				}
				
				time_since_last_step = 0; //restart distance calculator
				zero_crossed = 1; //start ZCD timer
				cross_found = 0;
				QPRINTF("\r\nsteps: %d\r\n", steps);
			}
			if(samp < 0)  //wave descending, zero crossing other direction
			{
				cross_found = 0;
			}
		}
		
		if(zero_crossed > 0)
		{
			zero_crossed++;
			if(zero_crossed > ZERO_DELAY)
			{
				zero_crossed = 0;
			}
		}
		
		samp_last = samp;
	}
	else //wait for enough samples
	{
		samples[samp_num] = xdat;
		samp_num++;
		
		//low pass filter
		samp_last = 0;
		for(i=0;i<4;i++)
		{
			samp_last += samples[i];
		}
		samp_last /= 4;
	}

	
}*/

/**
 ****************************************************************************************
 * @brief Setup vars for fancy pedometer function.
 ****************************************************************************************
 */


//for fancy pedometer
#define PED_WALK_FUDGE  0.0249
#define PED_AVGLEN 8
#define PED_LATENCY 4
#define PED_AVGCONST 1 //can be optimized if left as 1
#define PED_AVGTHRESH 3

// vars used by fancy_pedometer 
uint8_t stepflag; 
volatile float stride, avgstride, accel_dat[50]; 
volatile float maxavg, minavg, accel_avg, velocity, displace;

uint8_t i, cycle_count, tot_samples; 
int16_t rssdat, newmax, newmin, oldavg, newavg;

void setup_fancy_pedometer()
{
	stepflag = 2;
	maxavg = -10; 
	minavg = 10; 
	newmax = -10; 
	newmin = 10; 
	oldavg = 0; 
	newavg = 0; 
	cycle_count = 0; 
	tot_samples = 0; 
	steps = 0; 
	distance = 0; 
	accel_avg = 0; 
	velocity = 0; 
	displace = 0; 
	avgstride = 0; 
}

/**
 ****************************************************************************************
 * @brief Elaborate pedometer function based on Analog devices app note.
 *        After initial setup this function is called every time there is new data.
 *        About 90% accurate. Works very well.
 ****************************************************************************************
 */
void fancy_pedometer(int8_t xdat, int8_t ydat) 
{ 
	
	if (tot_samples > 7) // subtract first sample in sliding boxcar avg 
	{ 
		oldavg = newavg; 
		newavg -= accel_dat[cycle_count - PED_AVGLEN]; 
	} // if 
	//accel_get_sample(&xdat, &ydat, &zdat, ACCEL_XY); // get data from accelerometer 
	//xdat -= 255; // subtract Zero g value 
	//ydat -= 255; 
	rssdat = sqrt((float)(xdat*xdat + ydat*ydat)/16.0); // vector sum 
	accel_dat[cycle_count] = rssdat; // place current sample data in buffer 
	newavg += rssdat; // add new sample to sliding boxcar avg 
	if((abs(newavg-oldavg)) < PED_AVGTHRESH) 
	newavg = oldavg; 
	if (rssdat > newmax) 
	newmax = rssdat; 
	if (rssdat < newmin) 
	newmin = rssdat; 
	tot_samples++; 
	cycle_count++; // increment count of samples in current step 
	if (tot_samples > 8) 
	{ 
		//QPRINTF("%d, %d, %d, %d\r\n", newavg, oldavg, cycle_count, avglen);
		if (IsStep(newavg, oldavg)) 
		{ 
			for (i = PED_LATENCY; i < (cycle_count - PED_LATENCY); i++) 
				accel_avg += accel_dat[i]; 
			
			accel_avg /= (cycle_count - PED_AVGLEN); 
			for (i = PED_LATENCY; i < (cycle_count - PED_LATENCY); i++) 
			{ 
				velocity += (accel_dat[i] - accel_avg); 
				displace += velocity; 
			} // create integration and double integration 
			// calculate stride length 
			stride = displace * (newmax - newmin) / (accel_avg - newmin); 
			stride = sqrt(abs(stride)); 
			// use appropriate constant to get stride length 
			stride *= PED_WALK_FUDGE; 
			// generate exponential average of stride length to smooth data 
			if (steps < 2) 
				avgstride = stride; 
			else 
				avgstride = ((PED_AVGCONST-1)*avgstride + stride)/PED_AVGCONST; 

			steps++; 
			distance += avgstride; 
			// need all data used in calculating newavg 
			for (i = 0; i < PED_AVGLEN; i++) 
				accel_dat[i] = accel_dat[cycle_count + i - PED_AVGLEN]; 
			
			QPRINTF("STEPS: %d\t DIST: %d\t Vel: %.2f\r\n", steps, distance, avgstride);
			
			//reset tracking vars
			cycle_count = PED_AVGLEN; 
			newmax = -10; 
			newmin = 10;
			maxavg = -10; 
			minavg = 10; 
			accel_avg = 0; 
			velocity = 0; 
			displace = 0; 
			 
		} // we have a new step 
	} // enough samples to start checking for step (need at least 8) 
} // fancy_pedometer() 




/**
 ****************************************************************************************
 * @brief Called by fancy_pedometer() to determine based on sliding window if a step is
 *        taken. Needs to be updated to take ints, not floats.
 ****************************************************************************************
 */
char IsStep(float avg, float oldavg) 
{ 
	// this function attempts to determine when a step is complete 
	float step_thresh = 5.0; // used to prevent noise from fooling the algorithm 
	if (stepflag == 2) 
	{ 
		if (avg > (oldavg + step_thresh)) 
			stepflag = 1; 
		if (avg < (oldavg - step_thresh)) 
			stepflag = 0; 
		return 0; 
	} // first time through this function 
	if (stepflag == 1) 
	{ 
		if ((maxavg > minavg) && (avg > ((maxavg+minavg)/2)) && (oldavg < ((maxavg+minavg/2)))) 
			return 1; 
		if (avg < (oldavg - step_thresh)) 
		{ 
			stepflag = 0; 
			if (oldavg > maxavg) 
				maxavg = oldavg; 
		} // slope has turned down 
		return 0; 
	} // slope has been up 
	if (stepflag == 0) 
	{ 
		if (avg > (oldavg + step_thresh)) 
		{ 
			stepflag = 1; 
			if (oldavg < minavg) 
				minavg = oldavg; 
		} // slope has turned up 
		return 0; 
	} // slope has been down 
	return 0; 
} // IsStep() 

