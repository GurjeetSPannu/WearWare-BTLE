// performs pedometer and misc functions 
#include <math.h> 
#include <stdlib.h>
#include "app_env.h"
#include "lib.h"
#include "accel_lib.h"
#include "pedometer_lib.h"

volatile uint32_t steps = 0;
//volatile float distance;
volatile uint32_t distance = 0;
 
 
//helper function to get total steps
uint32_t getSteps(void)
{
	
	return steps;
}

//helper function to get total distance
uint32_t getDistance(void)
{
	//QPRINTF("Total Distance: %d\r\n", distance);
	return (int)distance;
}


/**
 ****************************************************************************************
 * @brief Very accurate pedometer (95+%) based on:
 *        "A Gyroscope Based Accurate Pedometer Algorithm" by Sampath Jayalath
 *        This function detects (using a state machine) the sin wave generated by
 *        walking. The accelerometer is using it's built-in high-pass filter to
 *        automatically return to zero and remove gravity.
 *
 * Initial Algorithm:
 * https://cuatrg.files.wordpress.com/2014/06/accurate-pedometer-for-smartphones.pdf
 * 
 * Distance Calculations:
 * http://www.rehab.research.va.gov/jour/04/41/6/pdf/Orendurff.pdf
 * http://scienceofsportsperformance.wordpress.com/2013/01/25/speed-development-plyometric-training/
 ****************************************************************************************
 */

//states for state machine
#define ST_INIT 					0
#define ST_ZERO_NEGATIVE	1
#define ST_LOWER_PEAK			2
#define ST_ZERO_POSITIVE	3
#define ST_HIGHER_PEAK		4
#define ST_CALC_STEP			5
#define ST_TIMER_WAIT			6

//constants
#define ZERO_DELAY 				7 // was 8
#define MIN_THRESHOLD 		5 // was 5
#define MAX_THRESHOLD 		200 // was 100
#define SAMPLE_RATE 			50 // was 20, now 50 for 50hz

//variables
int8_t samples[4];
int16_t samp_last;
uint16_t time_since_last_step = 0, step_timer = 0;;
uint8_t samp_num = 0;
uint8_t state = ST_INIT;

//base calculations on man, not woman
#define MAN

/*distance lookup tables based on walking/running pace
#if (defined(MAN))
	uint8_t stride_length[10] = {160,158,156,151,144,130,116,84,64,53}; //distance/step in cm	
#elif (defined(WOMAN))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm	
#elif (defined(CHILD))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm
#endif
*/

/*
#if (defined(MAN))
	uint8_t stride_length[10] = {110,109,108,105,100,90,76,60,46,38}; //distance/step in cm	
#elif (defined(WOMAN))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm	
#elif (defined(CHILD))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm
#endif
*/

#if (defined(MAN))
	uint8_t stride_length[10] = {225,222,215,197,192,188,68,60,46,38}; //distance/step in cm	
#elif (defined(WOMAN))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm	
#elif (defined(CHILD))
	uint8_t stride_length[10] = {98,97,96,93,89,80,68,53,41,34}; //distance/step in cm
#endif
	
	
//main algorithm
void better_pedometer(int8_t xdat)
{
	uint8_t  i;
	int16_t samp;
	
	//debug print
	//QPRINTF("%d, %d\r\n", xdat, state*4);
	
	/*if(time_since_last_step > 100)//2 seconds
	{
		//TODO: reduce sample rate and switch to slow sample sleep mode
	}*/

	//wait for enough samples to filter
	if(samp_num < 3) //wait for enough samples
	{
		samples[samp_num] = xdat;
		samp_num++;
		
		//averager filter
		samp_last = 0;
		for(i=0;i<4;i++)
		{
			samp_last += samples[i];
		}
		samp_last /= 4;
	}
	else //start running algorithm once averager filter is full
	{
		//copy new sample to filter array
		for(i=0;i<3;i++)
		{
			samples[i] = samples[i+1];
		}
		samples[3] = xdat;
		
		//low pass filter
		samp = 0;
		for(i=0;i<4;i++)
		{
			samp += samples[i];
		}
		samp /= 4;
		
		//state machine
		switch(state)
		{
			//start of machine
			case ST_INIT:
				if(samp_last >= 0 && samp <= -1) //zero crossing detector going down
				{
					state = ST_ZERO_NEGATIVE;
					time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
					step_timer = 0;// restart step timer
				}
			
				break;
				
			//zero-crossing found, look for lower peak
			case ST_ZERO_NEGATIVE: 
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp < -MAX_THRESHOLD) //peak too low, not a real step
					state = ST_INIT;
				else if(samp < -MIN_THRESHOLD) //lower peak
					state = ST_LOWER_PEAK;
				else if(samp >= 0) //Fake zero crosing
					state = ST_INIT;
				
				break;
			
			//low-point found, find wave crossing back up
			case ST_LOWER_PEAK:
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp_last <= 0 && samp >= 1) //zero crossing detector going up
					state = ST_ZERO_POSITIVE;
				else if(samp < -MAX_THRESHOLD) //peak too low, not a real step
					state = ST_INIT;
				
				break;
			
			// zero-cross going up found, find high point
			case ST_ZERO_POSITIVE:
				time_since_last_step++; // increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp > MAX_THRESHOLD) //peak too high, not a real step
					state = ST_INIT;
				else if(samp > MIN_THRESHOLD) //lower peak
					state = ST_HIGHER_PEAK;
				else if(samp <= 0) //Fake zero crosing
					state = ST_INIT;
				
				break;
			
			// high peak found, wait for it to go back down
			case ST_HIGHER_PEAK:
				time_since_last_step++;// increase timer by 1/sample rate seconds (20ms)
				step_timer++;
				if(samp < MIN_THRESHOLD) //peak on it's way down, step found
					state = ST_CALC_STEP;
				else if(samp > MAX_THRESHOLD) //peak too high, not a real step
					state = ST_INIT;
				
				break;
			
			case ST_CALC_STEP:
				step_timer++;
				if(step_timer > ZERO_DELAY) //protect against false fast step, ready for next step
				{
					//bypass init if zero corssing is happening already
					if(samp_last >= 0 && samp <= -1)
					{
						state = ST_ZERO_NEGATIVE;
						step_timer = 0;// restart step timer
					}
					else //otherwise always go to init
					{
						state = ST_INIT;
					}
				}
				else //if step happened too fast, wait before moving to get next step
				{
					state = ST_TIMER_WAIT;
				}

				steps++;
				
				QPRINTF("Time since last step:][': %d\r\n", (time_since_last_step/4));
				//compute distance traveled as inverse of step timer
				if(time_since_last_step > (SAMPLE_RATE-10)) //1 seconds since last step, too long for any cadence 
				{
					distance += stride_length[9]; //smallest step size
				}
				else if(time_since_last_step < (SAMPLE_RATE-10) && time_since_last_step > 9 ) //log table lookup
				{
					distance += stride_length[(time_since_last_step)/4];
				}
				else //super human fast!!!
				{
					distance += stride_length[0];
				}
				
				time_since_last_step = 0; //restart distance calculator
				break;
				
			// steps are happening too fast, it is impossible to run this fast so we skip measuring a step for every 150ms
			case ST_TIMER_WAIT:
				step_timer++;
				if(step_timer > ZERO_DELAY) //ready for next step
					state = ST_INIT;
				
				break;
			
			default:
				break;
			
		} //end switch
		
		//save this sample to be used in the next iteratio of the loop.
		samp_last = samp;
	}

	
}
